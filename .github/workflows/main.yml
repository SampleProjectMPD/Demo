name: Docker Image CI

on: [push]

# Environment variables available to all jobs and steps in this workflow
env:
  REGISTRY_NAME: githubactionspov
  CLUSTER_NAME: aksdemogithub
  CLUSTER_RESOURCE_GROUP: GithubDemo
  NAMESPACE: mydemoapp
  SECRET: githubdemosecret
  APP_NAME: demoapp
  
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@main
    - name: Run DevSkim scanner
      uses: microsoft/DevSkim-Action@v1

    - name: Upload DevSkim scan results to GitHub Security tab
      uses: github/codeql-action/upload-sarif@v2
      with:
        sarif_file: devskim-results.sarif
        
    - name: Analyze with SonarCloud         
      uses: SonarSource/sonarcloud-github-action@master
      env:
        GITHUB_TOKEN: ${{ secrets.GIT_ACCESS_TOKEN }}  # Needed to get PR information
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}   # Generate a token on Sonarcloud.io, add it to the secrets of this repo with the name SONAR_TOKEN (Settings > Secrets > Actions > add new repository secret)
      with:
        # Additional arguments for the sonarcloud scanner
        args:        
          -Dsonar.projectKey=avadevopspractice_SampleDemoApp
          -Dsonar.organization=avadevopspractice
    
    - name: Setup Java
      uses: actions/setup-java@v3
      with:
        java-version: 8
        distribution: 'temurin'

      # Prepare source+dependencies for upload. The default example is for a Maven project that uses pom.xml.
      # TODO: Update PACKAGE_OPTS based on the ScanCentral Client documentation for your project's included tech stack(s). Helpful hints:
      #   ScanCentral Client will download dependencies for maven (-bt mvn) and gradle (-bt gradle).
      #   ScanCentral Client can download dependencies for msbuild projects (-bt msbuild); however, you must convert the workflow to use a Windows runner.
      #   ScanCentral has additional options that should be set for PHP and Python projects
      #   For other build tools, add your build commands to download necessary dependencies and prepare according to Fortify on Demand Packaging documentation.
      #   ScanCentral Client documentation is located at https://www.microfocus.com/documentation/fortify-software-security-center/
    - name: Download Fortify ScanCentral Client
      uses: fortify/gha-setup-scancentral-client@5b7382f8234fb9840958c49d5f32ae854115f9f3
    - name: Package Code + Dependencies
      run: scancentral package $PACKAGE_OPTS -o package.zip
      env:
        PACKAGE_OPTS: "-bt none -yv 2 -o myPackage.zip"

    # Start Fortify on Demand SAST scan and wait until results complete. For more information on FoDUploader commands, see https://github.com/fod-dev/fod-uploader-java
    # TODO: Update ENV variables for your application and create the necessary GitHub Secrets.  Helpful hints:
    #   Credentials and release ID should be obtained from your FoD tenant (either Personal Access Token or API Key can be used).
    #   Automated Audit preference should be configured for the release's Static Scan Settings in the Fortify on Demand portal.
    - name: Download Fortify on Demand Universal CI Tool
      uses: fortify/gha-setup-fod-uploader@6e6bb8a33cb476e240929fa8ebc739ff110e7433
    - name: Perform SAST Scan
      run: java -jar $FOD_UPLOAD_JAR -z package.zip -aurl $FOD_API_URL -purl $FOD_URL -rid $FOD_RELEASE_ID -tc $FOD_TENANT -uc $FOD_USER $FOD_PAT $FOD_UPLOADER_OPTS -n $FOD_UPLOADER_NOTES
      env:
        FOD_URL: "https://trial.fortify.com/"
        FOD_API_URL: "https://api.trial.fortify.com/"
        FOD_TENANT: ${{ secrets.FOD_TENANT }}
        FOD_USER: ${{ secrets.FOD_USER }}
        FOD_PAT: ${{ secrets.FOD_PAT }}
        FOD_RELEASE_ID: ${{ secrets.FOD_RELEASE_ID }}
        FOD_UPLOADER_OPTS: "-ep 2 -pp 0 -I 1 -apf"
        FOD_UPLOADER_NOTES: 'Triggered by GitHub Actions (${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})'

    # Once scan completes, pull SAST issues from Fortify on Demand and generate SARIF output.
    - name: Export results to GitHub-optimized SARIF
      uses: fortify/gha-export-vulnerabilities@fcb374411cff9809028c911dabb8b57dbdae623b
      with:
        fod_base_url: "https://ams.fortify.com/"
        fod_tenant: ${{ secrets.FOD_TENANT }}
        fod_user: ${{ secrets.FOD_USER }}
        fod_password: ${{ secrets.FOD_PAT }}
        fod_release_id: ${{ secrets.FOD_RELEASE_ID }}

    # Import Fortify on Demand results to GitHub Security Code Scanning
    - name: Import Results
      uses: github/codeql-action/upload-sarif@v2
      with:
        sarif_file: ./gh-fortify-sast.sarif    
    
    # Connect to Azure Container Registry (ACR)
    - uses: azure/docker-login@v1
      with:
        login-server: ${{ env.REGISTRY_NAME }}.azurecr.io
        username: ${{ secrets.service_principal }} 
        password: ${{ secrets.service_principal_password }}
    
    # Container build and push to a Azure Container Registry (ACR)
    - name: ACR Push
      id: acr
      uses: azure/acr-build@v1
      with:
        service_principal: ${{ secrets.service_principal }}
        service_principal_password: ${{ secrets.service_principal_password }}
        tenant: ${{ secrets.tenant }}
        registry: ${{ secrets.registry }}
        repository: ${{ secrets.repository }}
        image: ${{ env.APP_NAME }}
        tag: ${{github.run_number}}
        git_access_token: ${{ secrets.git_access_token }}
        dockerfile: azure-vote/Dockerfile
        branch: master
    
  createSecret:
    permissions:
      contents: read
      id-token: write
    runs-on: ubuntu-latest
    needs: [build]
    steps:
    # Logs in with your Azure credentials
    - name: Azure login
      uses: Azure/login@v1
      with:
        creds: '{"clientId":"${{ secrets.service_principal }}","clientSecret":"${{ secrets.service_principal_password }}","subscriptionId":"${{ secrets.subscription_id }}","tenantId":"${{ secrets.tenant }}"}'

    # Retrieves your Azure Kubernetes Service cluster's kubeconfig file
    - name: Get K8s context
      uses: azure/aks-set-context@v2.0
      with:
        resource-group: ${{ env.CLUSTER_RESOURCE_GROUP }}
        cluster-name: ${{ env.CLUSTER_NAME }}

    # Retrieves the credentials for pulling images from your Azure Container Registry
    - name: Get ACR credentials
      run: |
        az acr update -n ${{ env.REGISTRY_NAME }} -g ${{ env.CLUSTER_RESOURCE_GROUP }} --admin-enabled true
        ACR_USERNAME=$(az acr credential show -g ${{ env.CLUSTER_RESOURCE_GROUP }} -n ${{ env.REGISTRY_NAME }} --query username -o tsv)
        ACR_PASSWORD=$(az acr credential show -g ${{ env.CLUSTER_RESOURCE_GROUP }} -n ${{ env.REGISTRY_NAME }} --query passwords[0].value -o tsv)
        echo "::add-mask::${ACR_USERNAME}"
        echo "::set-output name=username::${ACR_USERNAME}"
        echo "::add-mask::${ACR_PASSWORD}"
        echo "::set-output name=password::${ACR_PASSWORD}"
      id: get-acr-creds

    # Creates a kubernetes secret on your Azure Kubernetes Service cluster that matches up to the credentials from the last step
    - name: Create K8s secret for pulling image from ACR
      uses: Azure/k8s-create-secret@v1.1
      with:
        container-registry-url: ${{ env.REGISTRY_NAME }}.azurecr.io
        container-registry-username: ${{ steps.get-acr-creds.outputs.username }}
        container-registry-password: ${{ steps.get-acr-creds.outputs.password }}
        secret-name: ${{ env.SECRET }}  

  deploy:
    permissions:
      actions: read
      contents: read
      id-token: write
    runs-on: ubuntu-latest
    needs: [createSecret]
    steps:  
    # Checks out the repository this file is in
    - uses: actions/checkout@v3
    
    # Logs in with your Azure credentials
    - name: Azure login
      uses: Azure/login@v1
      with:
        creds: '{"clientId":"${{ secrets.service_principal }}","clientSecret":"${{ secrets.service_principal_password }}","subscriptionId":"${{ secrets.subscription_id }}","tenantId":"${{ secrets.tenant }}"}'
      
    # Retrieves your Azure Kubernetes Service cluster's kubeconfig file
    - name: Get K8s context
      uses: azure/aks-set-context@v2.0
      with:
        resource-group: ${{ env.CLUSTER_RESOURCE_GROUP }}
        cluster-name: ${{ env.CLUSTER_NAME }}        
        
    # Deploy app to AKS
    - uses: azure/k8s-deploy@v1
      with:
        manifests: azure-vote-all-in-one-redis.yaml
        images: |
          ${{ env.REGISTRY_NAME }}.azurecr.io/${{ env.APP_NAME }}:${{github.run_number}}
        imagepullsecrets: |
          ${{ env.SECRET }}
        namespace: ${{ env.NAMESPACE }}
